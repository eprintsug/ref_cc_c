#!/usr/bin/perl -w

use FindBin;
use lib "$FindBin::Bin/../../../perl_lib";

use strict;
use warnings;
use Text::CSV;
use Getopt::Long;
use Pod::Usage;

use EPrints;
my $eprintid;
my $nofilter;
my $version = 0;
my $verbose = 0;
my $help = 0;
my $man = 0;
my $update;
my $output_file;

Getopt::Long::Configure("permute");

GetOptions( 
	'help|?' => \$help,
	'man' => \$man,
	'verbose+' => \$verbose,
	'eprintid=s' => \$eprintid,
	'update' => \$update,
    	'output=s' => \$output_file,

);

# || pod2usage( 2 );
#pod2usage( 1 ) if $help;
#pod2usage( -exitstatus => 0, -verbose => 2 ) if $man;
#pod2usage( 2 ) if( scalar @ARGV != 1 ); 

my $repositoryid = $ARGV[0];

my $CSV_COUNT = 0;
my $UPDATE_COUNT = 0;
#unless($output_file) {die("Please supply an filename to output the results to");}

if(defined $update){
    my $warning_message = <<"END";
===You are about to run the REF Compliance Checker Checker in update mode!===

This means that the values calculated from the EPrints history will be used to update the following fields:
    - hoa_date_foa 
    - hoa_date_fcd

If you are unsure about any of the above say NO

Continue? [YES|NO]:
END

	print $warning_message;

   	my $answer = <STDIN>;
   	chomp $answer;
   	unless($answer =~ /YES|yes/){
		print "User said $answer, leaving now...\n";
		exit;
	}
}

#### Repo stuff ####
my $ep = EPrints->new();
my $repo = $ep->repository($repositoryid);
unless($repo) {die("could not find repository with id: $repositoryid");}
if(defined $output_file) {
   open(CSV_OUTPUT, '>', $output_file) or die("could not open $output_file: $!");
} else {
   *CSV_OUTPUT = *STDOUT;
}

print CSV_OUTPUT "eprintid,hoa_date_type,new_date_value,old_date_value,emb_len\n";

&check_fcds;

&check_foas;

&check_embargo_lifts;

print "REPORTED $CSV_COUNT values\n";
print "UPDATED $UPDATE_COUNT values\n" if $update;

sub check_fcds {

	#Get all events where something was moved out of inbox and not into deletion
	#ie the hefce_oa definition of deposit
	my $sql = "select historyid,objectid from history where datasetid = 'eprint' and action like 'move_inbox_to_%' and action != 'move_inbox_to_deletion'";
	$sql.=" and objectid = $eprintid " if(defined $eprintid);
	#order by timestamp to make sure we assess each lift embargo event in cronologically
	$sql.=" order by objectid, timestamp_year, timestamp_month, timestamp_day, timestamp_hour, timestamp_minute, timestamp_second";

	my @rows;
	my $sth = $repo->get_database->prepare_select( $sql );
	$repo->get_database->execute( $sth , $sql );
	my $found = $sth->rows();

	$repo->log("$found deposit events found...") if($verbose);

	#TODO check the compliance using revision data at this event.
	# if compliant then teimstamp == hoa_date_fcd
	# if not compliant future modification events should be checked to see if it becomes compliant
	check_compliance($sth,"fcd");

}

sub check_foas{

	#Get all events where something was moved in to the archive but not from deletion
	#ie the hefce_oa definition of an *eprint* being OA
	my $sql = "select historyid,objectid from history where datasetid = 'eprint' and action like 'move_%_to_archive' and action != 'move_deletion_to_archive'";
	$sql.=" and objectid = $eprintid " if(defined $eprintid);
	#order by timestamp to make sure we assess each lift embargo event in cronologically
	$sql.=" order by objectid, timestamp_year, timestamp_month, timestamp_day, timestamp_hour, timestamp_minute, timestamp_second";

	my @rows;
	my $sth = $repo->get_database->prepare_select( $sql );
	$repo->get_database->execute( $sth , $sql );
	my $found = $sth->rows();

	$repo->log("$found OA events found...") if($verbose);

	#TODO check the compliance using revision data at this event.
	# if compliant then teimstamp == hoa_date_foa
	# if not compliant and embargo is present check lift_embargos events to confirm foa
	# or future modification events should be checked to see if it becomes compliant
	check_compliance($sth,"foa");

}

sub check_embargo_lifts{

	#Get all the embargo lift events
	my $sql = "select historyid,objectid from history where datasetid = 'eprint' and actor like '%lift_embargos'";
	$sql.=" and objectid = $eprintid " if(defined $eprintid);
	#order by timestamp to make sure we assess each lift embargo event in cronologically
	$sql.=" order by objectid, timestamp_year, timestamp_month, timestamp_day, timestamp_hour, timestamp_minute, timestamp_second";

	my @rows;
	my $sth = $repo->get_database->prepare_select( $sql );
	$repo->get_database->execute( $sth , $sql );
	my $found = $sth->rows();

	$repo->log("$found lift_embargo events found...") if($verbose);

	#TODO check the compliance using revision data at this event.
	# if compliant then teimstamp == hoa_date_fcd
	# if not compliant future modification events should be checked to see if it becomes compliant
	check_compliance($sth,"foa");
}

sub check_compliance {

	my ($sth,$type) = @_;

	my $objectid_field = $repo->dataset("history")->get_field( "objectid" );
	my $historyid_field = $repo->dataset("history")->get_field( "historyid" );

	#keep per eprint flag for compliance
	my $hoa_comp = {};

	#Loop through the histor events returned by the SQL
	while( my @row = $sth->fetchrow_array )
	{
	   my $historyid = $historyid_field->value_from_sql_row( $repo, \@row );
	   my $eprintid = $objectid_field->value_from_sql_row( $repo, \@row );

	  #We'll want the eprint object in question to get some key dates from that
	  my ($eprint) = $repo->get_dataset("eprint")->list([$eprintid])->get_records( 0, 1 );	
	  next if !defined $eprint;

 	  my $eprint_type = $eprint->value("type");
	  next unless( defined $eprint_type && grep( /^$eprint_type$/, @{$repo->config( "hefce_oa", "item_types" )} ) );

	  next if($eprint->is_set("succeeds")); #this is a new version of an item... dates may hav carried
	  # We have an FOA/FCD calculated for this iitem no need to process further
	   next if $hoa_comp->{$eprintid};

	   #Get the history object
	   $repo->dataset("history")->list([$historyid])->map ( sub {
		my( undef, undef, $history ) = @_;

			# We have an FOA/FCD calculated for this iitem no need to process further
			return if $hoa_comp->{$eprintid};

			my $rev_file = get_rev_file($history);

			$repo->log($eprintid." ".$eprint->value("type")) if $verbose;
			$repo->log("Action: ".$history->value("action")) if $verbose;
			$repo->log("Timestamp: ".$history->value("timestamp")) if $verbose;
			$repo->log("Revision file: ".$rev_file) if $verbose;

			unless($rev_file){
				$repo->log("Revision file not found for ".$history->get_id." (".$history->value("revision").")");
				return;
			}

			#This timestamp will be the date that the embargo was lifted
			my $timestamp = Time::Piece->strptime( $history->value("timestamp"), "%Y-%m-%d %H:%M:%S");
			my $pub_date = get_pub_date($eprint);
			return if !defined $pub_date;
			#We'll need to look in that revision file to assess the state of play when the embargo was lifted
			my $doc = XML::LibXML->load_xml(location => $rev_file);
			my $xpc = XML::LibXML::XPathContext->new( $doc );
			$xpc->registerNs( "ep" => "http://eprints.org/ep2/data/2.0" );
			my $eprint_status = $xpc->find('//ep:eprint_status')->to_literal;
			#Double check that eprint_status at this point in history 
			#(may be a lift_embargo event on somethign that never left the review
			#If type == foa check that eprint is in archive
			return if($type eq "foa" && $eprint_status ne "archive");
			#If type == fcd cehck that eprint is in archive or buffer
			return if($type eq "fcd" && $eprint_status ne "archive" && $eprint_status ne "buffer");
			#Check that there is any document present at all
			return unless( $xpc->findnodes('//ep:document') );
	
			# Check documents to see if there is *any* document that meets the comploance criteria
			for my $item ( $xpc->findnodes('//ep:document') ) {
				my $i_xpc = XML::LibXML::XPathContext->new( $item ); #boring!
				$i_xpc->registerNs( "ep" => "http://eprints.org/ep2/data/2.0" );
				my $content = $i_xpc->find('ep:content')->to_literal;
				my $security = $i_xpc->find('ep:security')->to_literal;
       	       			next unless $content;
        			next unless $content eq "accepted" || $content eq "published";
        			next if $type eq "foa" && $security ne "public";
				
               			 #just to report the filename
				my $doc_main = $i_xpc->find('ep:main')->to_literal;
				
                		#emb_len calc...
				my $emb_len;
				if($i_xpc->find('ep:date_embargo')){ 
					#FIXME assumes that date_embargo will be set at deposit or maybe oa!!
                			#TODO perhaps we should be looping through *all* actions
					my $date_embargo = get_embargo_date($i_xpc->find('ep:date_embargo')->to_literal);
	
					my $len = $date_embargo-$pub_date;
					$emb_len = sprintf "%.0f", $len->months;

					$repo->log("Embargo detected (associated action: $type): ".$pub_date->strftime("%Y-%m-%d")." to ".$date_embargo->strftime("%Y-%m-%d")." ($emb_len)") if $verbose;
				}

				my $new_date_value = $timestamp->strftime("%Y-%m-%d");

				#Double check and amend if FCD is after the new FOA this can happen if 
				#compliance is achieved between deposit and publication 
				#(ie we miss the FCD cos we've only checked the status_change events)
				#FIXME this remedial work will only happen if the FOA < FCD is apparent at the point of FOA
				#TODO perhaps we should be looping through *all* actions
				if($type eq "foa"){
					my $FCD_date_value = Time::Piece->strptime( $eprint->value("hoa_date_fcd") , "%Y-%m-%d" );

					if($FCD_date_value > $timestamp){
						print CSV_OUTPUT "$eprintid,FCD after FOA,$new_date_value,$timestamp\n";
                         			if(defined $update){
    							$eprint->set_value("hoa_date_fcd",$new_date_value);
	    						$eprint->commit;
                        			}
					}
				}

		                #Get existing value to report on
				my $old_date_value = '';
				if($eprint->is_set("hoa_date_$type")){
					$old_date_value = $eprint->value("hoa_date_$type");
				}
                
				print CSV_OUTPUT "$eprintid,hoa_date_$type,$new_date_value,$old_date_value,";
			        print CSV_OUTPUT "$emb_len" if EPrints::Utils::is_set($emb_len);
				print CSV_OUTPUT "\n";
				$CSV_COUNT++;
				
                		if(defined $update){
					$eprint->set_value("hoa_date_".$type,$new_date_value);
					$eprint->set_value("hoa_emb_len",$emb_len) if EPrints::Utils::is_set($emb_len);
					$eprint->commit;
                    			$UPDATE_COUNT++;
				}
				#flag that we have compliance values for this eprint && stop loop,
				$hoa_comp->{$eprintid}=1;
				last;
			}		
	   });
	}

}

sub get_rev_file {
	my($history) = @_;

	#Get the revision data associated with the lift_embargo event
	my $rev_obj = $history->get_stored_file( "dataobj.xml" );
	if(!defined $rev_obj){
		#mpved_to events do not have revision files but they do have modify events with the same revision
		return get_rev_file(get_modify($history));
	}
	return $rev_obj->get_local_copy;
}

sub get_modify
{
    my( $history ) = @_;

    my $dataset = $history->get_dataset;

    my $revision = $history->get_value( "revision" );

    my $results = $dataset->search(
        filters => [
            {
                meta_fields => [ "datasetid" ],
                value => $history->value( "datasetid" ),
            },
            {
                meta_fields => [ "objectid" ],
                value => $history->value( "objectid" ),
            },
            {
                meta_fields => [ "revision" ],
                value => $revision,
            },
            {
                meta_fields => [ "action" ],
                value => "modify",
            }
        ]);

    return $results->item( 0 );
}


sub get_pub_date{
	my ($eprint) = @_;

	#Can we depend on this being there?
	my $hoa_pub = $eprint->value("hoa_date_pub");
	
	return if !defined $hoa_pub;
	
	#We'll use the same mthods and criteria that the REF_CC uses.
	#First thing is to get a calcuable publication time
	my $pub_date;
	if( $repo->can_call( "hefce_oa", "handle_possibly_incomplete_date" ) )
	{
		$pub_date = $repo->call( [ "hefce_oa", "handle_possibly_incomplete_date" ], $hoa_pub );
	}
	if( !defined( $pub_date ) ) #above call can return undef - fallback to default
	{
		$pub_date = Time::Piece->strptime( $hoa_pub , "%Y-%m-%d" );
	}
	return $pub_date;
}

sub get_embargo_date{
	my ($embargo_date) = @_;

	#Can we depend on this being there?
	return if !defined $embargo_date;
	
	#We'll use the same mthods and criteria that the REF_CC uses.
	#First thing is to get a calcuable publication time
	my $emb_date;
	if( $repo->can_call( "hefce_oa", "handle_possibly_incomplete_date" ) )
	{
		$emb_date = $repo->call( [ "hefce_oa", "handle_possibly_incomplete_date" ], $embargo_date );
	}
	if( !defined( $emb_date ) ) #above call can return undef - fallback to default
	{
		$emb_date = Time::Piece->strptime( $embargo_date , "%Y-%m-%d" );
	}
	return $emb_date;
}


